# 03장 HTTP 메시지

HTTP가 인터넷의 배달원이라면, HTTP메시지 는 무언가 담아 보내는 소포와 같다

이번장에서 할 내용은

- 메세지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메세지의 차이
- 요청 메세지가 지원하는 여러 기능(메서드들)
- 응답 메세지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

입니다

## 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.

인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미하는 용어이다, 트랜잭션 방향을 표현하기 위해 사용된다

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

- 인바운드 : 메세지가 원 서버쪽으로 향하는 것
- 아웃바운드 : 메시지가 사용자 에이전트(클라이언트)로 돌아오는것

![inbound_outbound](./images/InBound_OutBound.png)

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP는 요청 메시지나 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다

![downstream](./images/Downstream.png)

요청에서는 프락시 1이 프락시 3의 업스트림이지만, 응답에서는 프록시 3의 다운스트림이다.

## 3.2 메시지의 각 부분

<aside>
💡 메시지는 시작줄, 헤더블록, 본문 세 부분으로 이루어진다.

</aside>

시작줄 : 이것이 어떤 메세지인지 서술

헤더 블록 : 속성

본문 : 데이터 , 없을수도 있다

- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다, 각 줄은 캐리지 리턴(ascii 13)과 개행문자(ascii 10)로 구성된 두글자 줄바꿈 문자열로 끝난다 (이 줄바꿈 문자열을 CRLF 라고 쓴다.)
- HTTP 명세대로라면 줄바꿈 문자열은 CRLF이지만 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 한다. (오래되거나 잘못 만들어진 HTTP 애플리케이션은 캐리지리턴과 개행문자 모두를 전송하지 않을 수 있음)

- 엔티티 본문, 메시지 본문, 본문 등으로 불리는 본문은 단순한 데이터 덩어리이다
  없을수도 텍스트일수도 이진데이터일수도 있다
- 헤더는 본문에 대한 많은 정보를 준다
  - Content-Type : 본문의 타입 (text/plain, image/jpeg 등등)
  - Content-Length : 본문의 크기
    등등 본문에 대한 많은 정보를 준다

### 3.2.1 메시지 문법

![form](./images/HTTP_Message_Form.png)

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.

요청 메시지는 서버에 어떤 동작을 요구하고, 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다

요청과 응답 모두 기본적으로 구조가 같다

- 요청 메시지의 형식

  ```jsx
  <메서드> <요청 URL> <버젼>
  <헤더>
  <엔티티 본문>
  ```

- 응답 메시지의 형식

  ```jsx
  <버젼> <상태 코드> <사유 구절>
  <헤더>
  <엔티티 본문>
  ```

시작줄만 문법이 다르고 형식이 같다!

### **각 부분에 대한 설명**

- 메서드
  클라이언트 측에서 서버가 리소스에 대해 수행해주기 바라는 동작이다
  `GET` `POST` `HEAD` 와 같이 한단어로 되어있다
- 요청 URL
  요청 대상이 되는 리소스를 지칭하는 완전한 URL , 또는 URL의 경로 구성요소다
  완전하지 않아도 서버와 클라이언트가 직접 통신하고 있고, 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다, 생략된 호스트/포트는 서버가 자신을 가리키는것으로 간주할 것이다
- 버젼
  이 메시지에서 사용중인 HTTP의 버젼이다.
  `HTTP/<메이져>.<마이너>`
- 상태 코드
  요청 중에 무슨 일이 일어났는지 설명하는 세자리의 숫자이다.
  각 코드의 첫번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)을 나타낸다.
- 사유 구절

  숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명하는 짧은 문구

  상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다

  사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재한다.

  > `HTTP/1.0 200 OK` || `HTTP/1.0 200 NOT OK`
  >
  > 사유가 전혀 달라 보여도 동등하게 성공을 의미하는 것으로 처리되어야 함!

- 헤더들
  이름, 콜론(:) 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
  `Content-type : <값>`
  헤더들의 목록은 빈 줄로 끝나 헤더목록과 엔터티 본문의 시작을 표시한다
- 엔터티 본문
  엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메세지가 엔터티 본문이 있는게 아니라 때때로 메세지는 그냥 CRLF로 끝나게 된다
  ![structure](./images/HTTP_Message_structure.png)
  헤더나 엔터티 본문이 없더라도, HTTP 헤더의 집합은 그냥 빈줄(CRLF)로 끝나야 한다.
  역사적으로 많은 클라이언트와 서버가 엔터티 본문이 없는경우에 실수로 CRLF를 빠뜨릴 수 있어서, CRLF 없이 끝나는 메세지도 받아들일 수 있어야 한다.

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작한다.

요청 메시지의 시작줄은 무엇을 해야하는지 말해주고

응답 메시지의 시작줄은 무엇이 일어났는지 말해준다

- 요청줄 - 요청 메세지의 시작줄
  메서드, 요청 URL, HTTP 버젼이 들어있다
  요청줄에서 모든 필드는 공백(” “)으로 구분된다
- 응답줄 - 응답 메시지의 시작줄

  HTTP버젼, 상태코드,사유구절이 들어있다

  모든 필드는 공백으로 구분한다.

- 메서드 - 서버에게 무엇을 해야하는지 말해준다
  | 메서드 | 설명 | 본문이 있는가? |
  | ------- | ------------------------------------------------------ | -------------- |
  | GET | 서버에서 문서를 가져온다 | 없음 |
  | HEAD | 서버에서 문서에 대한 헤더만 가져온다 | 없음 |
  | POST | 서버가 처리해야할 데이터를 보낸다 | 있음 |
  | PUT | 서버에 요청 메시지의 본문을 저장한다 | 있음 |
  | TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 | 없음 |
  | OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다 | 없음 |
  | DELETE | 서버에서 문서를 제거한다 | 없음 |

- 상태 코드 - 서버에 무슨 일이 일어났는지 클라이언트에게 전달
  | 전체 범위 | 정의된 범위 | 분류 |
  | --------- | ----------- | ----------------- |
  | 100-199 | 100-101 | 정보 |
  | 200~299 | 200-206 | 성공 |
  | 300-399 | 300-305 | 리다이렉션 |
  | 400-499 | 400-415 | 클라이언트측 에러 |
  | 500-599 | 500-505 | 서버측 에러 |
  현재 버전의 HTTP는 각 상태 분류에 대해 적은 수의 코드만을 정의했지만, 프로토콜이 진화하면 더 많은 상태코드가 HTTP 명세에 공식적으로 정의될 것이다. 현재 인식할 수 없는 상태 코드를 받게되면 누군가가 현재 프로토콜의 확정으로 그것을 정의했을 가능성이 있다. 그럼 그 상태 코드를 그것이 포함하는 범주의 일반적인 구성원으로 다루어야 한다.
- 사유 구절 - 사람이 이해할 수 있는 글, 상태코드에 대한 글로된 설명

  어떠한 엄격한 규칙도 없다

- 버젼 번호 - HTTP/x.y 형식, 자신들이 따르는 프로토콜의 버젼을 말해주기 위한 수단
  HTTP로 대화하는 애플리케이션에게 대화 상대에 대한 능력과 메세지 형식에 대한 단어를 제공해주기 위함.
  ex) HTTP1.1 버젼 애플리케이션과 대화하는 HTTP1.2버젼 애플리케이션은 1.2 버젼을 사용할 수 없다.
  버젼 번호는 애플리케이션이 지원하는 가장 높은 HTTP버젼을 가리킨다
  주의! 버젼 번호는 메세지의 번호가 아니라, 메세지를 보낸 애플리케이션이 이해할수 있는 가장 최신의 HTTP 버전을 의미함

### 3.2.3 헤더

HTTP 명세는 여러 헤더 필드를 정의한다. 자유롭게 자신의 헤더를 만들어 낼 수 있다.

| 헤더 분류   | 설명                                        |
| ----------- | ------------------------------------------- |
| 일반 헤더   | 요청과 응답 양쪽에 모두 나타낼 수 있음      |
| 요청 헤더   | 요청에 대한 부가 정보를 제공                |
| 응답 헤더   | 답에 대한 부가 정보를 제공                  |
| Entity 헤더 | 본문 크기와 콘텐츠, 혹은 리소스 자체를 서술 |
| 확장 헤더   | 명세에 정의되지 않은 새로운 헤더            |

헤더는 이름, 쉼표, 공백(없어도됨), 필드값, CRLF가 순서대로 온다

![header](./images/Header.png)

- 헤더를 여러 줄로 나누기.
  긴 헤더의 경우, 여러 줄로 쪼개서 읽기 좋게 만들 수 있는데, 추가 줄 앞에 최소 하나의 스페이스 또는 탭 문자가 와야한다.
  ```jsx
  HTTP/1.0 200 OK
  Content-type: image/gif
  Content-Length: 8572
  Server: Test Server
  	Version 1.0
  ```
  Server헤더의 필드는 “Test Server Version 1.0” 이지만 탭 또는 스페이스를 추가해서 여러 줄로 쪼개 작성할 수 있다

### 3.2.4 엔터티 본문

HTTP 메세지의 화물, 메시지, 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 다양한 데이터를 나를 수 있다

### 3.2.5 버젼 0.9 메시지

![0.9v](./images/HTTP_message_0.9v.png)

HTTP 프로토콜의 초기 버젼으로, 훨씬 단순한 프로토콜로 되어있다.

0.9 버젼으로 작성된 애플리케이션도 있어서 레거시 대비를 해야 할 수도 있으니 설명한다..

## 3.3 메서드

### 3.3.1 안전한 메서드(Safe Method)

HTTP 요청의 결과로 서버에 어떤 작용도 없는 경우를 안전한 메서드라고 한다

GET, HEAD 같은 메서드들

안전한 메서드여도 서버에 작용할 수 있지만, 안전한 메서드를 굳이 구분해놓는 이유는, 안전하지 않은 메소드를 사용할 때 사용자에게 안전하지 않을수도 있단 사실을 알려주기 위함이다

ex) 웹 브라우져에서 POST 요청이 만들어 졌을때, 그 메서드를 읽고 예를들어 서버에서 신용카드가 결제된다거나, 하는 일이 일어날 수 있다는 경고를 알려줄수도있다

### 3.3.2 GET

가장 흔히 쓰이는 메서드, 서버에게 리소스를 달라고 요청하기 위해 쓰임

HTTP/1.1 준수를 위해서는 GET 메서드가 반드시 구현되어 있어야 한다

### 3.3.3 HEAD

정확히 GET처럼 행동하지만, 응답으로 헤더만을 돌려주고 엔터티 본문은 반환되지 않는다

HEAD 사용하는 이유

- 리소스를 가져오지 않고도 그에 대한 헤더 정보를 알아낼 수 있다
- 응답의 상태코드를 통해 개체가 존재하는지 알 수 있다
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다

서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보여야 한다.

HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다

### 3.3.4 PUT

서버에 문서를 쓸 때 사용

서버가 요청의 본문을 가지고 요청 URL대로 새 문서를 만들거나, 이미 URL이 존재한다면 메시지 본문으로 교체하는 것이다.

콘텐츠를 변경할 수 있게 해주기 때문에, 웹 서버가 PUT을 수행하기 전 비밀번호를 입력해서 로그인 하도록 요구할 것이다.

### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계되었다

### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때, 요청은 방화벽, 프락시 게이트웨이 등의 애플리케이션을 통과할 수 있다. TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다

![trace](./images/TRACE_Method.png)

TRACE는 주로 진단을 위해 사용된다. 예를 들면 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다, 또한 프락시나 다른 애플리케이션이 요청에 어떤 영향을 미치는지 확인할 때도 좋은 도구다

진단을 위해 사용할 때는 괜찮지만, GET, POST, HEAD 같은 메서드와는 다르게 다뤄질 수도 있다,

예를들어 프락시는 POST를 바로 서버로 통과시키는 반면 GET은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송한다

TRACE는 메서드를 구분하는 메커니즘을 제공하지 않는다. 중간 애플리케이션에 따라서 TRACE 요청이 다뤄질 수도 있다

### 3.3.7 OPTIONS

웹서버에게 여러가지 종류의 지원 범위에 대해 물어본다

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다

![options](./images/OPTIONS_Method.png)

### 3.3.8 DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다

하지만 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용해서, 실제로 안지워질수도 있다 무시 가능

### 3.3.9 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오작동을 유발하지 않는다.,

엄격하게 보내고 관대하게 받아들여라

ex) 이해할 수 없는 메서드를 받으면 501 코드로 처리# 03장 HTTP 메시지

HTTP가 인터넷의 배달원이라면, HTTP메시지 는 무언가 담아 보내는 소포와 같다

이번장에서 할 내용은

- 메세지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메세지의 차이
- 요청 메세지가 지원하는 여러 기능(메서드들)
- 응답 메세지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

입니다

## 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.

인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미하는 용어이다, 트랜잭션 방향을 표현하기 위해 사용된다

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

- 인바운드 : 메세지가 원 서버쪽으로 향하는 것
- 아웃바운드 : 메시지가 사용자 에이전트(클라이언트)로 돌아오는것

![inbound_outbound](./images/InBound_OutBound.png)

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP는 요청 메시지나 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다

![downstream](./images/Downstream.png)

요청에서는 프락시 1이 프락시 3의 업스트림이지만, 응답에서는 프록시 3의 다운스트림이다.

## 3.2 메시지의 각 부분

<aside>
💡 메시지는 시작줄, 헤더블록, 본문 세 부분으로 이루어진다.

</aside>

시작줄 : 이것이 어떤 메세지인지 서술

헤더 블록 : 속성

본문 : 데이터 , 없을수도 있다

- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다, 각 줄은 캐리지 리턴(ascii 13)과 개행문자(ascii 10)로 구성된 두글자 줄바꿈 문자열로 끝난다 (이 줄바꿈 문자열을 CRLF 라고 쓴다.)
- HTTP 명세대로라면 줄바꿈 문자열은 CRLF이지만 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 한다. (오래되거나 잘못 만들어진 HTTP 애플리케이션은 캐리지리턴과 개행문자 모두를 전송하지 않을 수 있음)

- 엔티티 본문, 메시지 본문, 본문 등으로 불리는 본문은 단순한 데이터 덩어리이다
  없을수도 텍스트일수도 이진데이터일수도 있다
- 헤더는 본문에 대한 많은 정보를 준다
  - Content-Type : 본문의 타입 (text/plain, image/jpeg 등등)
  - Content-Length : 본문의 크기
    등등 본문에 대한 많은 정보를 준다

### 3.2.1 메시지 문법

![form](./images/HTTP_Message_Form.png)

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.

요청 메시지는 서버에 어떤 동작을 요구하고, 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다

요청과 응답 모두 기본적으로 구조가 같다

- 요청 메시지의 형식

  ```jsx
  <메서드> <요청 URL> <버젼>
  <헤더>
  <엔티티 본문>
  ```

- 응답 메시지의 형식

  ```jsx
  <버젼> <상태 코드> <사유 구절>
  <헤더>
  <엔티티 본문>
  ```

시작줄만 문법이 다르고 형식이 같다!

### **각 부분에 대한 설명**

- 메서드
  클라이언트 측에서 서버가 리소스에 대해 수행해주기 바라는 동작이다
  `GET` `POST` `HEAD` 와 같이 한단어로 되어있다
- 요청 URL
  요청 대상이 되는 리소스를 지칭하는 완전한 URL , 또는 URL의 경로 구성요소다
  완전하지 않아도 서버와 클라이언트가 직접 통신하고 있고, 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다, 생략된 호스트/포트는 서버가 자신을 가리키는것으로 간주할 것이다
- 버젼
  이 메시지에서 사용중인 HTTP의 버젼이다.
  `HTTP/<메이져>.<마이너>`
- 상태 코드
  요청 중에 무슨 일이 일어났는지 설명하는 세자리의 숫자이다.
  각 코드의 첫번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)을 나타낸다.
- 사유 구절

  숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명하는 짧은 문구

  상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다

  사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재한다.

  > `HTTP/1.0 200 OK` || `HTTP/1.0 200 NOT OK`
  >
  > 사유가 전혀 달라 보여도 동등하게 성공을 의미하는 것으로 처리되어야 함!

- 헤더들
  이름, 콜론(:) 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
  `Content-type : <값>`
  헤더들의 목록은 빈 줄로 끝나 헤더목록과 엔터티 본문의 시작을 표시한다
- 엔터티 본문
  엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메세지가 엔터티 본문이 있는게 아니라 때때로 메세지는 그냥 CRLF로 끝나게 된다
  ![structure](./images/HTTP_Message_structure.png)
  헤더나 엔터티 본문이 없더라도, HTTP 헤더의 집합은 그냥 빈줄(CRLF)로 끝나야 한다.
  역사적으로 많은 클라이언트와 서버가 엔터티 본문이 없는경우에 실수로 CRLF를 빠뜨릴 수 있어서, CRLF 없이 끝나는 메세지도 받아들일 수 있어야 한다.

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작한다.

요청 메시지의 시작줄은 무엇을 해야하는지 말해주고

응답 메시지의 시작줄은 무엇이 일어났는지 말해준다

- 요청줄 - 요청 메세지의 시작줄
  메서드, 요청 URL, HTTP 버젼이 들어있다
  요청줄에서 모든 필드는 공백(” “)으로 구분된다
- 응답줄 - 응답 메시지의 시작줄

  HTTP버젼, 상태코드,사유구절이 들어있다

  모든 필드는 공백으로 구분한다.

- 메서드 - 서버에게 무엇을 해야하는지 말해준다
  | 메서드 | 설명 | 본문이 있는가? |
  | ------- | ------------------------------------------------------ | -------------- |
  | GET | 서버에서 문서를 가져온다 | 없음 |
  | HEAD | 서버에서 문서에 대한 헤더만 가져온다 | 없음 |
  | POST | 서버가 처리해야할 데이터를 보낸다 | 있음 |
  | PUT | 서버에 요청 메시지의 본문을 저장한다 | 있음 |
  | TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 | 없음 |
  | OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다 | 없음 |
  | DELETE | 서버에서 문서를 제거한다 | 없음 |

- 상태 코드 - 서버에 무슨 일이 일어났는지 클라이언트에게 전달
  | 전체 범위 | 정의된 범위 | 분류 |
  | --------- | ----------- | ----------------- |
  | 100-199 | 100-101 | 정보 |
  | 200~299 | 200-206 | 성공 |
  | 300-399 | 300-305 | 리다이렉션 |
  | 400-499 | 400-415 | 클라이언트측 에러 |
  | 500-599 | 500-505 | 서버측 에러 |
  현재 버전의 HTTP는 각 상태 분류에 대해 적은 수의 코드만을 정의했지만, 프로토콜이 진화하면 더 많은 상태코드가 HTTP 명세에 공식적으로 정의될 것이다. 현재 인식할 수 없는 상태 코드를 받게되면 누군가가 현재 프로토콜의 확정으로 그것을 정의했을 가능성이 있다. 그럼 그 상태 코드를 그것이 포함하는 범주의 일반적인 구성원으로 다루어야 한다.
- 사유 구절 - 사람이 이해할 수 있는 글, 상태코드에 대한 글로된 설명

  어떠한 엄격한 규칙도 없다

- 버젼 번호 - HTTP/x.y 형식, 자신들이 따르는 프로토콜의 버젼을 말해주기 위한 수단
  HTTP로 대화하는 애플리케이션에게 대화 상대에 대한 능력과 메세지 형식에 대한 단어를 제공해주기 위함.
  ex) HTTP1.1 버젼 애플리케이션과 대화하는 HTTP1.2버젼 애플리케이션은 1.2 버젼을 사용할 수 없다.
  버젼 번호는 애플리케이션이 지원하는 가장 높은 HTTP버젼을 가리킨다
  주의! 버젼 번호는 메세지의 번호가 아니라, 메세지를 보낸 애플리케이션이 이해할수 있는 가장 최신의 HTTP 버전을 의미함

### 3.2.3 헤더

HTTP 명세는 여러 헤더 필드를 정의한다. 자유롭게 자신의 헤더를 만들어 낼 수 있다.

| 헤더 분류   | 설명                                        |
| ----------- | ------------------------------------------- |
| 일반 헤더   | 요청과 응답 양쪽에 모두 나타낼 수 있음      |
| 요청 헤더   | 요청에 대한 부가 정보를 제공                |
| 응답 헤더   | 답에 대한 부가 정보를 제공                  |
| Entity 헤더 | 본문 크기와 콘텐츠, 혹은 리소스 자체를 서술 |
| 확장 헤더   | 명세에 정의되지 않은 새로운 헤더            |

헤더는 이름, 쉼표, 공백(없어도됨), 필드값, CRLF가 순서대로 온다

![header](./images/Header.png)

- 헤더를 여러 줄로 나누기.
  긴 헤더의 경우, 여러 줄로 쪼개서 읽기 좋게 만들 수 있는데, 추가 줄 앞에 최소 하나의 스페이스 또는 탭 문자가 와야한다.
  ```jsx
  HTTP/1.0 200 OK
  Content-type: image/gif
  Content-Length: 8572
  Server: Test Server
  	Version 1.0
  ```
  Server헤더의 필드는 “Test Server Version 1.0” 이지만 탭 또는 스페이스를 추가해서 여러 줄로 쪼개 작성할 수 있다

### 3.2.4 엔터티 본문

HTTP 메세지의 화물, 메시지, 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 다양한 데이터를 나를 수 있다

### 3.2.5 버젼 0.9 메시지

![0.9v](./images/HTTP_message_0.9v.png)

HTTP 프로토콜의 초기 버젼으로, 훨씬 단순한 프로토콜로 되어있다.

0.9 버젼으로 작성된 애플리케이션도 있어서 레거시 대비를 해야 할 수도 있으니 설명한다..

## 3.3 메서드

### 3.3.1 안전한 메서드(Safe Method)

HTTP 요청의 결과로 서버에 어떤 작용도 없는 경우를 안전한 메서드라고 한다

GET, HEAD 같은 메서드들

안전한 메서드여도 서버에 작용할 수 있지만, 안전한 메서드를 굳이 구분해놓는 이유는, 안전하지 않은 메소드를 사용할 때 사용자에게 안전하지 않을수도 있단 사실을 알려주기 위함이다

ex) 웹 브라우져에서 POST 요청이 만들어 졌을때, 그 메서드를 읽고 예를들어 서버에서 신용카드가 결제된다거나, 하는 일이 일어날 수 있다는 경고를 알려줄수도있다

### 3.3.2 GET

가장 흔히 쓰이는 메서드, 서버에게 리소스를 달라고 요청하기 위해 쓰임

HTTP/1.1 준수를 위해서는 GET 메서드가 반드시 구현되어 있어야 한다

### 3.3.3 HEAD

정확히 GET처럼 행동하지만, 응답으로 헤더만을 돌려주고 엔터티 본문은 반환되지 않는다

HEAD 사용하는 이유

- 리소스를 가져오지 않고도 그에 대한 헤더 정보를 알아낼 수 있다
- 응답의 상태코드를 통해 개체가 존재하는지 알 수 있다
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다

서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보여야 한다.

HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다

### 3.3.4 PUT

서버에 문서를 쓸 때 사용

서버가 요청의 본문을 가지고 요청 URL대로 새 문서를 만들거나, 이미 URL이 존재한다면 메시지 본문으로 교체하는 것이다.

콘텐츠를 변경할 수 있게 해주기 때문에, 웹 서버가 PUT을 수행하기 전 비밀번호를 입력해서 로그인 하도록 요구할 것이다.

### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계되었다

### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때, 요청은 방화벽, 프락시 게이트웨이 등의 애플리케이션을 통과할 수 있다. TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다

![trace](./images/TRACE_Method.png)

TRACE는 주로 진단을 위해 사용된다. 예를 들면 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다, 또한 프락시나 다른 애플리케이션이 요청에 어떤 영향을 미치는지 확인할 때도 좋은 도구다

진단을 위해 사용할 때는 괜찮지만, GET, POST, HEAD 같은 메서드와는 다르게 다뤄질 수도 있다,

예를들어 프락시는 POST를 바로 서버로 통과시키는 반면 GET은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송한다

TRACE는 메서드를 구분하는 메커니즘을 제공하지 않는다. 중간 애플리케이션에 따라서 TRACE 요청이 다뤄질 수도 있다

### 3.3.7 OPTIONS

웹서버에게 여러가지 종류의 지원 범위에 대해 물어본다

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다

![options](./images/OPTIONS_Method.png)

### 3.3.8 DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다

하지만 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용해서, 실제로 안지워질수도 있다 무시 가능

### 3.3.9 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오작동을 유발하지 않는다.,

엄격하게 보내고 관대하게 받아들여라

ex) 이해할 수 없는 메서드를 받으면 501 코드로 처리
