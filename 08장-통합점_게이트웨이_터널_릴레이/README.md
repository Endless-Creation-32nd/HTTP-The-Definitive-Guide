## 8.1 게이트웨이

- HTTP의 확장과 인터페이스가 발전함에 따라 웹에서 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것이 분명해졌다.
- 이러한 문제의 해결책으로서 리소스를 받기 위한 경로를 안내하는 역할인 게이트웨이 개념을 고안해냈다.
- **게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.**
- 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고 게이트웨이는 그에 맞게 동적인 컨텐츠를 생성하거나, 데이터베이스에 질의를 보내는 등의 응답을 할 수 있다.

![1](https://user-images.githubusercontent.com/108210492/223047119-e1feaa79-3f1b-4ede-9835-caaf73708aa2.png)

- 위 그림을 보면 게이트웨이는 서버와 데이터베이스 중간역할을 하는 리소스 게이트웨이이다.
- 게이트웨이는 HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버로 접속할 수 있도록, HTTP 트래픽을 자동으로 다른 프로토콜로 변환한다.

![2](https://user-images.githubusercontent.com/108210492/223047123-6e1c0caf-1101-4fef-940a-463453fd2a8b.png)

- (a)에서 게이트웨이는 FTP URL을 가리키는 HTTP 요청을 받는다. 게이트웨이는 FTP와 커넥션을 맺고, FTP서버에 적절한 명령을 전송한다. 클라이언트는 적절한 HTTP 헤더와 함께 HTTP를 통해서 문서를 받는다
- (b)에서 게이트웨이는 암호화된 웹 SSL을 통해 요청을 받고 요청을 해독해서 생성한 일반 HTTP요청을 목적지 서버로 전달한다.이런 보안 가속기는 원 서버에 고성능 암호화 기능을 제공할 목적으로 웹 서버의 바로 앞단에 위치시킬 수 있다.
- (c)에서 게이트웨이는 애플리케이션 서버 게이트웨이 API를 통해서 HTTP 클라이언트를 서버측 애플리케이션 프로그램에 연결한다. 웹에서 물건을 사거나 일기예보를 보거나 할 때 사실은 애플리케이션 서버 게이트웨이를 방문하는 것이다.

### 8.1.1 클라이언트 측 게이트웨이와 서버측 게이트웨이

- 웹 게이트웨이는 **한 쪽에선 HTTP로 통신**하고, **다른 한 쪽에선 다른 프로토콜로 통신**한다.
- 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금으로 구분해 기술한다.
  - HTTP 클라이언트와 NNTP 뉴스 서버 사이에 있으면 HTTP / NNTP 게이트웨이가 된다.
  - **서버 측 게이트웨이는 클라이언트와 HTTP로 통신**하고, **서버와는 외래 프로토콜로 통신**한다.
  - **클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신**하고, **서버와는 HTTP로 통신**한다.

## 8.2 프로토콜 게이트웨이

- 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.
- 보통 명시적으로 게이트웨이를 설정하여 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리 서버로 설정할 수도 있다.
  ![3](https://user-images.githubusercontent.com/108210492/223047124-912fab18-24a7-45c9-8e48-aa138e388da0.png)

- 일반적인 HTTP 트래픽은 바로 원서버로 보낸다.
- FTL URL을 포함한 요청은 FTP 요청으로 변환하여 처리한 뒤 클라이언트에게 결과를 HTTP로 전송한다.

### 8.2.1 Http/\*: 서버 측 웹 게이트웨이

서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.

![4](https://user-images.githubusercontent.com/108210492/223047127-37e08e60-7503-42af-bae5-f4ba82327c94.png)

- 위 그림 8-5에서 게이트웨이는 원 서버의 FTP 포트로 FTP 커넥션을 연결하고 FTP 프로토콜을 통해서 객체를 가져온다.
- 여기서 게이트웨이가 하는 역할
  - USER와 PASS 명령을 보내서 서버에 로그인한다
  - 서버에서 적절한 디렉터리로 변경하기 위해 CWD 명령을 내린다.
  - 다운로드 형식을 ASCII로 설정한다.
  - MDTM으로 문서의 최근 수정 시간을 가져온다.
  - PASV로 서버에게 수동형 데이터 검색을 하겠다고 말한다.
  - RETV로 객체를 검색한다
  - 제어 채널에서 반환된 포트로 FTP 서버에서 데이터 커넥션을 맺고, 데이터 채널이 열리는 대로 객체가 게이트웨이로 전송된다.

### 8.2.2 Http/Https: 서버 측 보안 게이트웨이

- 기업 내부의 모든 웹 요청을 암호화함으로써 개인정보보호와 보안을 제공하는 데 게이트웨이를 사용할 수 있다.

![5](https://user-images.githubusercontent.com/108210492/223047098-e41274a5-9aa4-4d0d-a596-eb7c004e1e87.png)

- 클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화할 것이다.

### 8.2.3 Https/Http: 클라이언트 측 보안 가속 게이트웨이

![6](https://user-images.githubusercontent.com/108210492/223047104-476d4051-ecdb-43dd-8de1-af160ee74987.png)

- HTTPS/HTTP 게이트웨이는 보안 가속기로 유명하다.
- 이 HTTPS/HTTP 게이트웨이는 웹 서버의 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다.
- 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.
- 이런 게이트웨이는 원 서버의 부하를 줄여주기도 하지만, 게이트웨이와 원서버 간의 암호화하지 않은 트래픽을 전송하기 때문에 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야 한다.

### 8.3 리소스 게이트웨이

![7](https://user-images.githubusercontent.com/108210492/223047106-98d2d57d-45da-4230-8068-a229a04bc998.png)

- 애플리케이션 서버는 게이트웨이의 가장 일반적인 형태이다.
- 이 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버측 게이트웨이이다.
- 두 개의 클라이언트가 HTTP를 사용하여 애플리케이션 서버로 연결한다.
- 하지만 서버로부터 파일이 전송되는 대신, 애플리케이션 서버는 게이트웨이의 API(Application Programming Interface)를 통해 요청을 서버에서 동작하고 있는 애플리케이션에 전달한다.

  - 클라이언트 A의 요청을 받으면, 그 요청의 URI를 따라서 API를 통해 디지털 카메라 애플리케이션에 요청이 전송된다.
  - HTTP 응답 메시지는 최종 카메라 이미지를 감싸 클라이언트로 전송하고 클라이언트의 브라우저에 보인다.
  - 클라이언트 B의 URI는 전자상거래 애플리케이션을 가리킨다. 클라이언트 B의 요청은 서버 게잍웨이 API를 통해 전자상거래 소프트웨어로 전송되고 결과는 브라우저로 전송된다.
  - 전자상거래 소프트웨어는 클라이언트와 통신하며 사용자가 순차적인 HTML 페이지를 통해서 구매를 완료할 수 있게 한다.

- 최초의 API는 공용 게이트웨이 인터페이스, CGI (Common Gateway Interface)였다.
- CGI는 웹 서버가 사용하는 표준화된 인터페이스 집합이다.

![8](https://user-images.githubusercontent.com/108210492/223047111-67c7db38-3edc-45e2-98f9-1281edb20aa6.png)

- 게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 핼퍼 애플리케이션을 생성하여 요청을 처리한다.
- 헬퍼 애플리케이션은 필요한 데이터를 전달받는다
- 전달받은 데이터는 요청 전체이거나 사용자가 데이터베이스에서 실행시키려는 질의 같은 것이다.
- 그 다음 바로 클라이언트에게 전달할 응답이나 응답 데이터를 서버에 반환한다.
- 이 프로토콜은 가장 오래되고 널리 쓰이는 CGI이다.

### 8.3.1 공용 게이트웨이 인터페이스 (CGI)

![9](https://user-images.githubusercontent.com/108210492/223047113-eb977a75-e393-4cdd-a8b7-e0c9b87ef6c0.png)

- CGI는 최초의 서버 확장이자 지금도 널리 쓰이는 서버 확장이다.
- 이는 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공하는 데에 쓰인다.
- CGI 애플리케이션이 서버와 분리되면서 Perl, Tcl, C, 셸 언어를 포함한 많은 언어로 구현할 수 있게 되었다.
- CGI는 거의 모든 HTTP 서버가 지원한다.
- 사용자에게는 CGI가 내부에서 어떤 처리를 하는 지 보이지 않는다.
- 그리고 서버와 CGI 애플리케이션 간에 진행되는 처리 단계를 감춘다.
- URL에 ‘cgi’ 혹은 ‘?’ 같은 것을이 있다면 CGI 애플리케이션이 무언가 하고있다는 뜻이다.
- CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공한다.
- 인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭하고 할 수 있다.
- 만약 문제가 있는 확장이 서버 자체에 들어가면 에러를 발생시키고 서버를 뻗게할 것이다.
- 그러나 이러한 분리때문에 성능에 관한 비용이 발생한다.
- 모든 CGI 요청마다 새로운 프로세스를 만드는 데 따르는 부하가 꽤 크고, CGI를 사용하는 서버의 성능을 제한하며 서버 장비에 부담을 준다.
  ![10](https://user-images.githubusercontent.com/108210492/223047115-a16e207f-1d58-4b1b-a3cf-ea845d4f4ecb.png)
- 이런 문제를 피하고자 새로운 CGI 형식인 Fast CGI가 개발되었다.

### 8.3.2 서버 확장 API

- CGI 프로토콜은 구동중인 HTTP 서버에 외부 인터프리터가 쉽게 접속할 수 있게는 해준다.
- 하지만 서버 자체의 동작을 바꾸고 싶거나 서버의 처리능력을 최고치로 끌어올리기 위해선 서버 확장 API가 필요하다.
- 서버 확장 API는 하나의 프로세스에서 여러 개의 스레드(Thread)를 생성해서 클라이언트의 요청을 처리한다.
- 확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 하였다.
