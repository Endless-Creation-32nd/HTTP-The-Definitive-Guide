## 14.6 디지털 인증서

- 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증받은 사용자나 회사에 대한 정보를 담고있다.
- 디지털 인증서는 흔히 cert라고 불리고 마치 인터넷 신분증과 같다고 볼 수 있다.

### 14.6.1 인증서의 내부

- 디지털 인증서에는 공식적으로 인증기관에 의해 디지털 서명된 정보의 집합이 담겨있다.
- 보통 아래 다섯가지가 기본적으로 들어있다.
  - 대상의 이름(사람, 서버, 조직 등)
  - 유효기간
  - 인증서 발급자(누가 이 인증서를 보증하는가)
  - 인증서 발급자의 디지털 서명
- 추가적으로 디지털 인증 대상과 사용된 서명 알고리즘에 대한 정보 뿐 아니라 공개키도 담고있다.
- 누구나 디지털 인증서를 만들 수 있지만, 그 모두가 인증서의 정보를 보증하고, 인증서를 개인키로 서명할 수 있는 권한을 얻는 것은 아니다.

![HTTPS(1)](https://user-images.githubusercontent.com/108210492/227269739-32e2a2ea-ad62-41a9-b5bc-c2055e303259.png)

### 14.6.2 X.509 v3 인증서

- 디지털 인증서에 대한 전 세계적인 단일 표준은 없다.
- 그러나 오늘날 사용되는 인증서의 대부분은 그들의 정보를 X.509라 불리는 표준화된 서식에 저장하고 있다는 것이다.
- X.509 v3인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공한다.
  | 필드 | 설명 |
  | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | 버전 | 인증서가 따르는 X.509 인증서 버전의 번호, 요즘은 보통 버전 3이다 |
  | 일련번호 | 인증기관에 의해 생성된 고유한 정수, CA로부터의 각 인증서는 반드시 고유한 일련번호를 가져야한다. |
  | 서명 알고리즘 ID | 서명을 위해 사용된 암호 알고리즘, 예를들어 “RSA 암호화를 이용한 MD2 요약” |
  | 인증서 발급자 | 인증서를 발급하고 서명한 기관의 이름, X.500 포맷으로 기록되어있다. |
  | 유효 기간 | 인증서가 유효한 기간. 시작일과 종류일로 정의된다 |
  | 대상의 이름 | 인증서에 기술된 사람이나 조직과 같은 엔터티. 이 대상의 이름은 X.500으로 기록되어있다 |
  | 대상의 공개 키 정보 | 인증 대상의 공개 키, 공개 키에 사용된 알고리즘, 추가 매개변수 |
  | 발급자의 고유 ID(선택) | 발급자의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한 식별자 |
  | 대상의 고유 ID(선택) | 대상의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한 식별자 |
  | 확장 | 선택적인 확장 필트의 집합. 각 확장 필드는 중요한 것인지 그렇지 않은지가 표시되어있다. 중요한 확장은 중요하기 때문에 인증서 사용자에 의해 반드시 이해되어야한다. 만약 인증서 사용자가 중요한 확장 필드를 이해하지 못한다면 인증서를 거절해야한다. 흔히 쓰이는 확장들에는 다음과 같은 것들이 있다. 기본제약, 인 증서 정책, 키 사용이 그 예이다. |
  | 인증기관 서명 | 위의 모든 필드에 대한 인증기관의 디지털 서명. 명시된 서명 알고리즘을 사용한다. |

### 14.6.3 서버인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.

- 서버 인증서는 다음을 포함한 많은 필드를 갖고있다
  - 웹 사이트의 이름과 호스트 명
  - 웹 사이트의 공개키
  - 서명 기관의 이름
  - 서명 기관의 서명
- 브라우저가 인증서를 받으면, 서명기관은 검사한다
- 만약 그 기고나이 공공이 신뢰할만한 서명이관이라면 브라우저는 그것의 공개키를 이미 알고있을 것이며, 브라우저는 그 서명을 검정할 수 있다.

![HTTPS(2)](https://user-images.githubusercontent.com/108210492/227269741-b86ca001-c256-42bb-90e7-92d364238952.png)

## 14.7 HTTPS의 세부사항

- HTTPS는 HTTP의 가장 유명한 보안 버전이다. 널리 구현되었으며 주류 상용 브라우저와 서버에 구현되어있다.
- HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.
- HTTPS는 인터넷 애플리케이션의 성장을 가속한 동시에 웹 기반 전자상거래의 고속 성장을 이끄는 주력이다.

### 14.7.1 HTTPS 개요

![HTTPS(3)](https://user-images.githubusercontent.com/108210492/227269743-94839e55-6b01-4131-acdc-397b3cb4966e.png)

- HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP 이다.
- 암호화되지 않은 HTTP 메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안계층으로 보낸다.
- 오늘날 HTTPS의 보안 계층은 SSL이나 SSL의 현대 대체품인 TLS로 구현되었다.

### 14.7.2 HTTPS 스킴

- 보안 HTTP는 선택적이다. 따라서 웹 서버로의 요청을 만들 때, 우리는 웹 서버에게 URL 스킴을 통해 HTTP의 보안 프로토콜 버전을 수행한다고 말해준다.

  ```jsx
  // 보안 없는 일반적인 HTTP는 URL의 스킴 접두사는 http이다.
  http://www.joes-hardware.com/index.html

  // 보안이 되는 HTTPS 프로토콜에서 URL의 스킴 접두사는 https이다.
  https://developer.mozilla.org/en-US/docs/Web/HTTP
  ```

- 웹 브라우저 등의 클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다.
  ![HTTPS(4)](https://user-images.githubusercontent.com/108210492/227269748-e53e4f58-4363-4698-9d23-1faaf376ed9c.png)
  - 만약 URL이 http 스킴을 갖고 있다면, 클라이언트는 서버에 80번(기본값)포트로 연결하고 평범한 HTTP 명령을 전송한다.
  - 만약 URL이 https 스킴을 갖고있다면, 클라이언트는 서버에 443번(기본값)포트로 연결하고서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 ‘핸드셰이크’를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.
  - SSL 트래픽은 바이너리 프로토콜이기 때문에, HTTP와는 완전히 다르다.
  - 그 트래픽은 다른 포트로 전달된다.(SSL은 보통 443포트) 만일 SSL과 HTTP 트래픽 모두 80번 포트로 도착한다면, 대부분의 웹 브라우저는 바이너리 SSL 트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫을 것이다.

### 14.7.3 보안 전송 셋업

![HTTPS(5)](https://user-images.githubusercontent.com/108210492/227269756-9576c5e2-b9b8-4fbf-81ca-e64c2cb22fb6.png)

- 암호화되지 않은 HTTP에서 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫는다.
- HTTPS에서의 절차는 SSL 보안 계층 때문에 약간 더 복잡하다.
- HTTPS에서 클라이언트는 먼저 웹 서버의 443 포트로 연결한다.
- 연결이 되고 나면 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.
- 핸드 셰이크가 완료되면 SSL 초기화는 완료되며 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다. 이 메시지는 TCP로 보내지기 전에 암호화된다.

### 14.7.4 SSL 핸드셰이크

- 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다. 핸드 셰이크는 다음과 같은 일이 일어난다
  - 프로토콜 버전 번호 교환
  - 양쪽이 알고있는 암호 선택
  - 양쪽의 신원을 인증
  - 채널을 암호화하기 위한 임시 세션 키 생성
    ![HTTPS(6)](https://user-images.githubusercontent.com/108210492/227269672-a9c029df-f3aa-4467-a4ad-141c2e2654f3.png)
- 암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고받는다.

### 14.7.5 서버 인증서

- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다.
- 그러나 오늘날, 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다.
- 하지만 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
- 잘 알려진 인증기관에 의해 서명된 서버 인증서는 서버에 개인정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와준다.
- 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는 X.503 v3에서 파생된 인증서이다.

![HTTPS(7)](https://user-images.githubusercontent.com/108210492/227269682-fd596c4b-1a6b-4f1f-a538-5686b854f72d.png)

### 14.7.6 사이트 인증서 검사

- SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹 브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.
- 넷 스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹 브라우저의 검사기법의 기초를 구축 했다.
- 웹 서버 인증서 검사를 위한 알고리즘 수행 단계

  1. 날짜 검사

     브라우저는 인증서의 유효성을 확인하기 위해 인증서의 시작 및 종료일을 검사한다. 인증서가 만료됐거나 활성화되지 않았다면 인증서 검사는 실패하고 브라우저는 에러를 보여준다.

  2. 서명자 신뢰도 검사

     모든 인증서는 서버를 보증하는 어떤 인증기관에 의해 서명되어있다. 여러 수준의 인증서가 있는 데, 각각은 다른 수준의 배경 검증을 요구한다.

     브라우저는 신뢰할만한 서명 기관의 목록을 포함한 채 배포되며 만일 브라우저가 알려져있지 않은 인증기관으로부터 서명된 인증서를 받았다면 브라우저는 경고를 보여준다.

  3. 서명검사

     한번 서명 기관이 믿을만하다고 판단되면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.

  4. 사이트 신원 검사

     서버가 누군가 다른 이의 인증서를 복사하거나 그들의 트래픽을 가로채는 것을 방지하기 위해 대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는 지 검사한다. 서버 인증서에는 보통 단일 도메인 이름이 들어있지만 몇몇 CA는 서버 클러스터나 퍼버 팜을 위해 서버의 이름의 목록이나 서버 이름에 대한 와일드카드 표현이 들어있는 인증서르 만든다.

     만일 호스트명이 인증서의 신원과 맞지 않는다면, 사용자를 우선으로 생각하는 클라이언트는 반드시 이 사실을 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야한다.

### 14.7.7 가상 호스팅과 인증서

- 가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
- 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다.
- 만일 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트명에 도착했다면 경고 상자가 나타날 것이다.
- 예를들어
  - 루이지에나 풍의 전자상거래 사이트인 Cajun-Shop.com이 있다고 해보자.
  - 이 사이트의 호스팅 제공자는 공식이름 cajun-shop.securesites.com을 제공했다
  - 사용자가 [https://www.cajun-shop.com으로](https://www.cajun-shop.com으로) 접속했을 때, 서버 인증서에 나열된 공식 호스트명(securesites.com)은 사용자가 브라우징한 가상 호스트명([www.cajun-shop.com](https://www.cajun-shop.com으로))과 맞지 않으므로 경고가 나타난다.

![HTTPS(8)](https://user-images.githubusercontent.com/108210492/227269693-a9a1d3d0-1ded-4aaf-9634-4c3492f9b97f.png)

    - 이러한 문제를 피하기 위해 Cajun-Shop.com의 소유자는 보안 트랜잭션을 시작하는 모든 사용자를 cajun-shop.securesites.com으로 리다이렉트한다. 가상호스팅되는 사이트의 인증서 관리는 까다로울 수 있다.

## 14.8 진짜 HTTPS 클라이언트

- SSL은 복잡한 바이너리 프로토콜이다.
- 몇 가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다.

### 14.8.1 OpenSSL

- OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 규현이다.
- OpenSSL 프로젝트는 강력한 다목적 암호법 라이브러리인 동시에 SSL과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 상용 수준의 툴킷을 개발하고자 한 자원 봉사자들의 협업 결과물이다.
- OpenSSL은 SSLeay 라이브러리를 계승하였으며, 인터페이스가 매우 비슷하다.

### 14.8.2 간단한 HTTPS 클라이언트

- HTTPS 클라이언트를 작성하기 위해 OpenSSL 패키지를 이용할 수 있다.
- 이 클라이언트는 서버와 SSL 커넥션을 맺고, 그 사이트 서버로부터 가져온 신원 정보를 출력하고, HTTP GET 요청을 보안 채널을 통해 보내고, HTTP 응답을 받아 그 응답을 출력할 것이다.
- 코드의 대략적인 과정은 다음과 같다
  1. SSL 라이브러리 초기화
  2. 서버의 호스트 명을 IP 주소로 변환
  3. 서버의 443 포트로 TCP 커넥션을 연다
  4. TCP 커넥션을 통해 SSL 핸드셰이크 개시
  5. 협상을 통해 선택된 암호를 출력
  6. 서버 인증서 출력
  7. 핸드셰이크 완료 - SSL을 통해 HTTP 요청을 보낸다
  8. SSL 스택으로부터 HTTP 응답을 읽어들인다
  9. 모두 끝났으므로 커넥션을 닫고 정리한다.

### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기

- 단순 OpenSSL 클라이언트 실행 과정은 다음과 같다
  1. SSL 초기화
  2. clients1.online.msdw.com의 IP주소 : 63.151.15.11
  3. 호스트 [clients1.online.msdw.com](http://clients1.online.msdw.com), 포트 443으로 TCP 커넥션을 열었습니다.
  4. SSL 종단이 생성되었으며 핸드셰이크가 완료되었습니다.
  5. 다음의 암호로 SSL 연결이 되었습니다: `DES-CBC3-MD5`
  6. 서버 인증서를 받았습니다 :

![HTTPS(9)](https://user-images.githubusercontent.com/108210492/227269702-ea13d42f-2f3a-4d5e-8f32-cbbdd82707f3.png)

    7. 암호화된 채널을 통해 HTTP 요청을 보냈습니다

        ```jsx
        GET / HTTP / 1.0
        Host: clients1.online.msdw.com:443
        Connection: close
        ```

    8. HTTP 응답에서 615 바이트를 가져왔습니다.

![HTTPS(10)](https://user-images.githubusercontent.com/108210492/227269707-615b1c75-6bb8-49d1-9700-321591bda0db.png)

    9. 모두 끝났으므로 커넥션을 닫고 정리합니다.

- 1~4번이 진행 완료되자마자 클라이언트는 열린 SSL 커넥션을 갖게 된다.
- 클라이언트는 커넥션의 상태와 선택된 매개변수에 대해 물어보고 서버의 인증서를 검증할 수 있다.
- 이 예에서 클라이언트와 서버는 `DES-CBC3-MD5` 대량 암호화 암호를 쓰는 것으로 함의했다.
- 또한 서버 사이트 인증서가 ‘미국 유타 솔트레이크 시티’의 모근 스탠리 조직에 속해있다는 것도 확인할 수 있다.
- 이 인증서는 RSA 데이터 시큐리티에 의해 승인돼었으며, 우리의 요청에 대응하는 호스트 명은 ‘clients1.online.msdw.com’이다.
- 한편 SSL 채널이 수립되고 클라이언트가 사이트 인증서를 안심하고 받아들이게 되면 클라이언트는 자신의 HTTP 요청을 보안 채널을 통해 전송한다.
- 이 예에서 클라이언트는 “GET/HTTP/1.0” HTTP 요청을 보내고 사용자가 다른 URL로 이동하도록 요청하는 302 Redirect 응답을 받는다.

## 14.9 프락시를 통한 보안 트래픽 터널링

![HTTPS(11)](https://user-images.githubusercontent.com/108210492/227269723-b8755729-0a7c-40fb-90a0-0532a97103be.png)

- 클라이언트는 종종 웹 프락시 서버를 이용한다.
- 웹 프락시 서버는 클라이언트를 대신하여 웹 서버에 접근하는 역할을 한다.
- 이 프락시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며 바이러스 검사나 기타 콘텐츠 제어를 수행할 것이다.

![HTTPS(12)](https://user-images.githubusercontent.com/108210492/227269733-7f1ab1a4-47da-4700-9be9-1ded1ff7fce2.png)

- 그러나 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면 프락시는 더이상 HTTP 헤더를 읽을 수 없다.
- 더이상 HTTP 헤더를 읽을 수 없다면 프락시는 어디로 요청을 보내야 하는 지 알 수 없게 된다.
- HTTPS가 프락시와도 잘 동작할 수 있게 하기 위해 클라이언트가 프락시에게 어디에 접속하려는 지 말해주는 방법을 수정해줘야 한다.
- HTTPS SSL 터널링 프로토콜

  - 클라이언트는 먼저 프락시에게 자신이 연결하고자하는 안전한 호스트와 포트를 말해준다.
  - 클라이언트는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전 평문으로 말해준다.
  - HTTP는 CONNEXT라 불리는 새로운 확장 메서드를 이용해서 평문으로 된 종단 정보를 전송하기 위해 사용된다.
  - CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호를 연결 해달라고 말해주며, 그게 완료되면 클라이언트와 서버 사이에서 데이터가 직접적으로 오갈 수 있는 터널을 만든다.
  - CONNECT 메서드는 안전한 원 서버의 호스트 명과 포트를 콜론으로 구분된 형태로 제공하는 한 줄로 된 텍스트 명령이다.
  - 0개 이상의 HTTP 요청 헤더줄들이 이어진 다음, 빈 줄 하나가 온다. 빈 줄 다음에 만약 커넥션을 수립하기 위한 핸드셰이크가 성공했다면 SSL 데이터 전송이 시작된다.

    ```jsx
    CONNECT home.netscape.com:443 HTTP/1.0
    User-agent: Mozilla/1.1N

    //<SSL로 암호화된 데이터가 이 다음에 온다>
    ```

  - 요청의 빈 줄 다음에 클라이언트는 프락시로부터의 응답을 기다릴 것이다.
  - 프락시는 요청을 평가하며 요청의 유효성과 사용자의 요청 허가여부를 확인한다.
  - 만일 적법하다면 200 Connection Established 응답을 클라이언트에게 보낸다
    ```jsx
    HTTP/1.0 200 Connection established
    Proxy-agent: Netscape-Proxy/1.1
    ```
