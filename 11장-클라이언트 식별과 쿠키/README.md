# 11장 클라이언트 식별과 쿠키

- 웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다.
- 이 서버들은 클라이언트의 요청을 처리하는 것 뿐만 아니라 서버와 통신하고있는 **클라이언트를 추적해야할 수도 있다.**
- 이 장에서는 서버가 통신하는 대상을 식별하는 데에 사용되는 기술을 알아본다.

## 11.1 개별 접촉

- HTTP는 익명으로 사용하며 상태가 없고 독립적으로 일어나는 **요청과 응답으로 통신하는 프로토콜**이다.
- 서버
  - 서버는 클라이언트가 보낸 요청을 처리하고, 클라이언트에게 전송한다.
  - 요청을 보낸 사용자를 식별하거나, 방문자가 보낸 연속적 요청을 추적하기 위해 약간의 정보를 이용한다.
- 세션 추적
  - 많은 웹 사이트에서는 사용자가 사이트와 상호작용 할 수 있도록 사용자의 상태를 남긴다 (ex. 장바구니 기능)
  - 이렇게 상태를 유지하려면 웹사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.
  - HTTP 자체에는 식별 관련 기술이 풍부하지 않아서 초기 웹 사이트 설계자들은 사용자를 식별하는 기술을 개발했다.
- 현대 웹 사이트는 여러 가지 방식으로 사이트를 개인화 시켜서 개인화된 서비스를 제공하고 싶어한다.
- 개인화의 예시
  - 개별인사
    온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.
  - 사용자 맞춤 추천
    온라인 상점은 고객의 흥미가 무엇인지 학습해서 고객이 좋아할 것이라고 예상되는 제품들을 추천할 수 있다. 고객의 생일이나 중요한 날이 다가오면 특별한 제품을 제시하기도 한다.
  - 지정 사용자 정보
    온라인 쇼핑 고객은 복잡한 주소와 신용카드 정보를 매번 입력하는 것을 싫어하기 때문에 이런 정보를 데이터베이스에 저장하여 쇼핑을 더 편하게 할 수 있도록 한다.

## 11.2 HTTP 헤더

- 아래 표는 사용자에 대한 정보를 전달하는 가장 일반적인 일곱 가지 HTTP 요청 헤더이다.

![cookie_1](https://user-images.githubusercontent.com/108210492/225888822-7aef4446-3b86-4553-9638-1257edad3cd4.png)

- From 헤더
  - 사용자의 이메일 주소를 포함한다.
  - 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From 헤더를 사용하는 브라우저는 많지 않다.
  - 예를 들어 크롤링하는 과정에서 로봇이 웹사이트에 문제를 일으켰을 때, 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 From 헤더에 이메일 주소를 기술한다.
  ```jsx
  From: webmaster@example.org
  ```
- User-Agent 헤더

  - 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 어떤 경우엔 OS에 대한 정보까지 서버에게 알려준다.
  - 이는 특정 브라우저에서 제대로 동작하도록 콘텐츠를 최적화하는 데 유용할 수 있지만, 사용자 식별엔 큰 도움되지 않는다.
  - 예를 들어 이 헤더에서 사용자가 IE를 사용하고 있다고 확인되면 다른 브라우저를 이용하라는 메시지를 띄우기도 한다.
    ```jsx
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5)
    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36
    ```

- Referer 헤더
  - 사용자가 현재 페이지로 유입하게 한 웹 페이지의 URL을 가리킨다.
  - 이 헤더를 통해 사용자의 웹 사용 행태나 사용자의 취향을 더 잘 파악할 수 있다.
  ```jsx
  Referer: https://developer.mozilla.org/en-US/docs/Web/JavaScript
  ```

## 11.3 클라이언트 IP 주소

- 초기 웹 선구자들은 사용자 식별에 클라이언트 IP 주소를 사용하려 했다.
- 이 방식은 사용자가 확실한 IP 주소를 가지고 있고, 그 주소가 거의 바뀌지 않고, 서버 요청마다 IP를 알 수 있다면 문제 없이 동작한다.
- 그러나 클라이언트 IP 주소로 사용자를 식별하는 방식은 다음과 같은 약점을 가진다.
  - 여러 사용자가 같은 컴퓨터를 사용하는 경우 식별이 불가하다.
  - ISP는 사용자 로그인 시 IP 주소를 동적으로 할당하기 때문에 사용자는 매번 다른 IP 주소를 받는다.
  - 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 사용하는 경우 NAT는 실제 IP를 방화벽 뒤로 숨기고 방화벽 내부 IP주소로 변환한다.
- 최근엔 클라이언트 IP 주소를 통해 사용자를 식별하는 방식이 제대로 동작하지 않기 때문에 사용하지 않는다.

## 11.4 사용자 로그인

- 웹 서버는 사용자에게 로그인을 요구해 보다 명시적으로 사용자에게 식별 요청을 할 수 있다.
- 웹 사이트는 로그인이 더 쉽도록 HTTP는 WWW-Authenticate와 Authorization 헤더를 사용해 웹사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
- 한 번 로그인 하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.

![cookie_2](https://user-images.githubusercontent.com/108210492/225888827-fe68c13a-5bf2-4fc1-931b-115c47ac1110.png)

- 서버에서 사용자가 사이트에 접근하기 전에 로그인 시키고자 한다면 HTTP 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.
- 브라우저는 로그인 대화 상자를 보여주고, 다음 요청부터 Authorization 헤더에 그 정보를 기술하여 보낸다.
- 이에 대해선 12장에서 자세히 다룰 것이다.

## 11.5 뚱뚱한 URL

- 어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였다.
- 보통 URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다.
- 사용자가 그 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.
- 사용자의 상태정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 한다.
- 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 세선 혹은 방문으로 묶는 용도로 뚱뚱한 URL을 사용할 수 있다.
- 사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생기고, 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가 되며 서버는 클라이언트를 이 뚱뚱한 URL로 리다이랙트 시킨다.
- 서버가 뚱뚱한 URL을 포함한 요청을 받으면, 사용자 아이디와 관련된 추가적인 정보를 찾아서 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꾼다.
- 그러나 이 기술엔 여러 문제가 있다
  - 못생긴 URL
    브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다.
  - 공유하지 못하는 URL
    뚱뚱한 URL은 사용자의 개인정보를 포함하고 있기 때문에 그 주소를 누군가에게 보낸다면 사용자의 개인정보를 보여주는 꼴이 된다.
  - 캐시를 사용할 수 없음
    URL을 만든다는 것은 URL이 달라지기 때문에 기존 캐시에 접근할 수 없다는 것을 의미한다.
  - 서버 부하 가중
    서버는 뚱뚱한 URL에 해당하는 HTML페이지를 다시 그려야 한다
  - 이탈
    사용자가 링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청해서 의도치 않게 뚱뚱한 URL 세션이서 이탈하기 쉽다. 이런 경우 지금까지의 진척사항 (장바구니에 채워진 상품들)은 초기화 된다.
  - 세션 간 지속성의 부재
    사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.

### 11.6.1 쿠키의 타입

`세션 쿠키(session cookie)와 지속 쿠키(persistent cookie)` 두 가지 타입으로 나뉜다.

- `세션 쿠키`
  - 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시쿠키
  - 브라우저를 닫으면 삭제됨
- `지속 쿠키`
  - 삭제되지 않고 더 길게 유지
  - 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작해도 남아있음
  - 주기적으로 방문하는 사이트 정보나 로그인 이름을 유지

둘의 다른 점은 `파기되는 시점`뿐이다.
파기되는 시점을 가리키는 Expires 혹은 Max-Age 파라미터가 없으면 세션쿠키다.

### 11.6.2 쿠키는 어떻게 동작하는가

![HTTP4 001](https://user-images.githubusercontent.com/39042837/103439857-fa60b280-4c83-11eb-8a63-9841d1a50674.jpeg)

- (A) 처음 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해 아무것도 모른다.
- (B) 웹 서버는 사용자가 다시 왔을 때, 해당 사용자를 식별하기 위한 **유일한 값**을 쿠키에 할당한다.
  그 리스트는 **Set-cookie 또는 Set-cookie2** 같은 HTTP 응답 헤더에 전달한다.
- 브라우저는 서버에게 받은 Set-cookie 헤더에 있는 **쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장**한다.
- (C) 사용자가 다시 같은 사이트를 방문하면, 브라우저는 서버가 이 사용자에게 할당했던
  쿠키를 **Cookie 요청 헤더**에 기술해 전송한다.

쿠키는 단순히 ID 번호만 넘기는 것은 아니며, 다른 정보들도 쿠키에 유지할 수 있다.

> Cookie: name="rowanlee92"; phone="1234-777"

### 11.6.3 쿠키 상자: 클라이언트 측 상태

브라우저는 쿠키 정보를 저장할 책임이 있다. 이 시스템을 **클라이언트 측 상태** 라고 한다.
쿠키명세의 공식적인 이름은 `HTTP 상태 관리 체계(HTTP State Management Mechanism)`이다.

#### 구글 크롬 쿠키

![image](https://user-images.githubusercontent.com/39042837/103449179-eea6d780-4ce7-11eb-84b7-d0038540cac7.png)

Mac의 경우 `~/Library/Application Support/Google/Chrome/Default/Cookies` 파일이
구글 크롬 쿠키 SQLite 파일이다.

각 주요 필드의 의미는 다음과 같다.

**creation_utc**

쿠키가 생성된 시점을 초 단위로 기술

**host_key**

쿠키의 도메인

**name**

쿠키의 이름

**value**
쿠키의 값

**path**

쿠키와 관련된 도메인에 있는 경로

**expires_utc**

쿠키의 파기 시점을 초 단위로 기술

**is_secure**

이 쿠키를 SSL 커넥션일 경우에만 보낼지 여부

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 수백 수천 개의 쿠키를 가질 수 있지만, 쿠키 전부를 모든 사이트에 보내지 않는다.
보통 각 사이트에 2~3개의 쿠키만을 보낸다.

이유는 다음과 같다.

- 쿠키를 모두 전달하면 성능이 크게 저하. 모두 전달하면 브라우저는 실제 콘텐츠의 바이트보다
  더 많은 쿠키 바이트를 전달하게 된다.
- 쿠키 대부분 서버에 특화된 name/value 쌍을 포함하기 때문에, 대부분의 사이트에서는 무의미한 값이다.
- 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 보안에 문제를 일으킬 수 있다.

브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

google.com에서 생성된 쿠키는 google에만 보내고
naver.com에서 생성된 쿠키는 naver에만 보낸다.

#### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 Set-cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가
해당 쿠키를 읽을 수 있는지 제어할 수 있다.

```
Set-cookie: user="rowanlee92"; domain="github.com"
```

예를 들어 사용자가 www.github.com, www.test.github.com처럼
.github.com으로 끝나는 사이트를 방문하면 Cookie 헤더가 항상 적용된다.

```
Cookie: user="rowanlee92"
```

#### 쿠키 Path 속성

URL 경로의 앞부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달할 수 있다.

```
Set-cookie: pref=compact; domain="github.com"; path=/pro/
```

www.github.com으로 접근하면

```
Cookie: user="rowanlee92"
```

쿠키 한 개를 얻을 수 있고

www.github.com/pro/로 접근하면

```
Cookie: user="rowanlee92"
Cookie: pref=compact
```

두 가지 쿠키를 얻는다.

따라서, 쿠키는 일종의 **상태정보**라고 할 수 있다.

### 11.6.5 쿠키 구성요소

쿠키 명세에는 Version 0 쿠키(넷스케이프 쿠키), Version 1 쿠키(RFC 2965)가 있다.

> Version 1은 RFC 6265 "HTTP State Management Mechanism"에 의해 폐기됨

### 11.6.6 Version 0(넷스케이프) 쿠키

최초의 쿠키는 넷스케이프가 정의함.

```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]

Cookie: name1=value1 [; name2=value2] ...
```

**_Set-Cookie 헤더_**

Set-Cookie 헤더는 `name=value` 이름과 값을 가져야 한다. 쿠키 옵션 속성들은
세미콜론으로 이어서 기술한다.

아래의 표는 Set-Cookie 필드 정보이다.
Set-Cookie 속성|설명 및 용례
:---|:---
name=value|(필수) 큰따옴표로 감싸지 않고 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열
Expires|(선택) 쿠키의 생명주기를 가리키는 날짜 문자열. 사용할 수 있는 타임존은 GMT. Expires가 없다면 세션 쿠키
Domain|(선택)이 속성에 기술된 도메인을 사용하는 서버로만 쿠키를 전송. 도메인 명시되어있지 않으면, Set-Cookie 응답을 생성한 서버의 호스트 명이 기본값으로 사용됨
Path|(선택) 서버에 있는 특정 경로만 쿠키를 할당. 경로가 명시되어있지 않으면, Set-Cookie 응답을 전달하는 URL의 경로가 사용됨
Secure|(선택)이 속성이 포함되면, 쿠키는 HTTP가 SSL 보안 연결 사용할 때만 전달

**_Cookie 헤더_**

클라이언트가 서버에 요청 보낼 때는, Domain, Path, Secure 필터들이 현재 요청하려는
사이트에 적합하면 파기되지 않은 쿠키들을 함께 보낸다.
모든 쿠키는 Cookie 헤더에 이어 붙여 보낸다.

```
Cookie: session-id=002-123341-4444444; session-id-time=1007884800
```

### 11.6.7 Version 1 (RFC 2965) 쿠키

- Version 1은 Set-Cookie2, Cookie2 헤더를 소개하며 Verion 0 시스템과도 호환된다.
- 현재는 사용하지 않는다.

### 11.6.8 쿠키와 세션 추적

![](https://user-images.githubusercontent.com/24623403/225888780-b9a60e8e-3ba0-4673-adfd-78807bb0c9d8.png)

사용자가 Amazon.com에 방문하면 일어나는 트랜젝션의 연속을 설명한다. 이때 세션 쿠키가 사용된다.

- 브라우저가 Amazon.com 루트 페이지를 요청
- 서버는 클라이언트를 전자상거래 소프트웨어 URL로 리다이렉트
- 클라이언트는 리다이렉트 URL로 요청
- 서버는 응답에 두 개의 세션 쿠키를 기술 후, 사용자를 다른 URL로 리다이렉트.
- 클라이언트는 앞에 받은 두 개의 쿠키와 함께 새로운 URL로 요청
- 서버는 home.html 페이지로 리다이렉트 시키고 쿠키 두 개를 추가적으로 첨부
- 클라이언트는 home.html 페이지를 요청하고 총 4개의 쿠키를 전달
- 서버는 콘텐츠를 보낸다.

### 11.6.9 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.
이전 사용자의 쿠키가 다른 사용자에게 할당되거나, 누군가의 개인 정보가 다른 사람에게 노출될 수 있기 때문이다.

**_캐시 되지 말아야 할 문서가 있다면 표시하라_**

문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면 문서에 명시적으로
`Cache-Control: no-cache="Set-Cookie"`를 기술한다.
또한, 캐시를 해도 되는 문서에 `Cache-Control: public`을 사용

**_Set-Cookie 헤더를 캐시 하는 것에 유의하라_**

캐시가 모든 요청마다 원서버와 재검사시켜 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술할 수 있도록
원서버는 다음의 헤더를 캐시 문서에 추가한다.

```버
Cache-Control: must-revalidate, max-age=0
```

**_Cookie 헤더를 가지고 있는 요청을 주의하라_**

Cookie 헤더가 오면, 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트다.
개인 정보는 캐시 되지 않도록 표시되어야 하지만, 그 표시를 하지 않는 서버도 있다.

Set-Cookie가 있는 이미지에 대해서는 캐시를 하지만, 텍스트는 캐시를 하지 않는 캐시도 있다.
따라서, 캐시 이미지에 파기 시간이 0인 Cookie 헤더를 설정해서 매번 재검사하도록 강제한다.

### 11.6.10 쿠키, 보안 그리고 개인정보

개인정보 정책에만 유의한다면, 쿠키에 관련된 위험성보다 세션 조작이나 트랜젝션상의 편리함이 더 크다.
