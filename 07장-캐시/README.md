# 7장-캐시

- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다.
- 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면 그 문서는 원 서버가 아닌 캐시로부터 제공된다.
- 캐시의 혜택
  - 불필요한 데이터 전송을 줄여 네트워크 비용을 줄여줌
  - 네트워크 병목을 줄여줌, 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 됨
  - 원 서버에 대한 요청을 줄여줌, 서버의 부하가 줄어들며 빨리 응답할 수 있게 됨
  - 페이지를 먼 곳에서 불러올 수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여줌

## 7.1 불필요한 데이터 전송

- 여러 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 **같은 문서**를 클라이언트들에게 한번씩 전송하게 된다
- 똑같은 바이트들이 네트워크를 통해 **반복해서** 이동한다. → 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹게 된다 → 전송이 느려지고, 서버에 부하를 준다
- 캐시를 이용하면 첫번째 서버 응답은 캐시에 보관된다 → 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용된다
- 캐시된 사본으로 원 서버가 증폭해서 트래픽을 주고받는 낭비가 줄어들게 된다

## 7.2 대역폭 병목

- 캐시는 네트워크 병목을 줄여준다
- 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면 캐싱은 성능을 대폭 개선할 수 있을 것이다(특히 큰 문서에 대해서는)

![image7-1](./images/7-1.png)

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 중요하다
- 갑작스런 사건(뉴스 속보, 스팸 메일, 유명 인사와 관련된 사건 등)으로 많은 사람이 거의 동시에 웹 문서에 접근할 때 이런 일이 발생한다
- 이 결과로 초래된 불필요한 트래픽 증가는 서버에 심각한 장애를 야기시킨다

![image7-2](./images/7-2.png)

## 7.4 거리로 인한 지연

- 거리로 인한 지연 → 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다
- 클라이언트-서버 사이의 라우터가 많지는 않더라도 빛의 속도 그 자체가 유의미한 지연을 유발한다
- 만약 웹 페이지가 20개의 이미지를 포함하고 있고 이 모두가 샌프란치스코에 있는 한 서버에 들어가 있다고 가정해보자
  ```markdown
  보스턴과 샌프란시스코 거리: 약 4,400km
  빛의 속도로 왕복하는 시간: 30ms
  ```
  - 보스턴에 있는 클라이언트가 4개의 커넥션을 열고 그 커넥션을 유지한다면 이미지를 다운받는데 빛의 속도로 인한 지연은 거의 1/4초(240ms)가 된다
  - 신호는 빛의 속도보다는 약간 느리게 이동하므로 240ms보다 더 많은 시간이 소요될 것이다
  - 또한 거리가 더 멀다면 더 많은 시간을 소요할 것이다
  - 하지만 보스턴 근처에 캐시를 설치해서 문서가 전송되는 거리를 줄일 수 있다 → 지연시간을 줄일 수 있다

![image7-3](./images/7-3.png)

## 7.5 적중과 부적중

- 캐시가 모든 문서의 사본을 저장하지는 않는다
  - 때로는 자주 변경되는 문서의 경우 캐시를 항상 신선하게 유지하지는 못한다
- 캐시 요청이 도착했을 때 그에 대응하는 사본이 있다면 이 사본으로 요청을 처리할 수 있다. 이것을 캐시 적중(cache hit) 이라고 부른다
- 만약 사본이 없다면 그냥 원 서버로 전달하기만 할 뿐이다. 이것을 캐시 부적중(cache miss)이라고 부른다.

![image7-4](./images/7-4.png)

### 7.5.1 재검사(Revalidation)

- 원 서버는 콘텐츠는 변경될 수 있기 때문에 캐시는 반드시 그들이 갖고 있는 사본이 최신인지 서버를 통해 때때로 점검해야 한다. 이를 **HTTP 재검사**라고 부른다
  - 효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했다
- 캐시는 스스로 언제든지 사본을 재검사할 수 있다
  - 하지만 캐시된 문서는 수백만개인 경우가 흔한데 비해 네트워크 대역폭은 부족하다
  - **따라서 대부분의 캐시는 클라이언트가 사본을 요청했으며 그 사본이 검사가 필요할 수 있을 정도로 충분히 오래됐을 때만 재검사를 한다**
- 캐시는 재검사가 필요할 때 원 서버에 작은 재검사 요청을 보낸다

  - 콘텐츠가 변경되지 않았다면 `304 Not Modified` 응답을 보낸다 → 여전히 캐시가 유효하므로 그 사본이 신선하다고 임시로 표시하고 클라이언트에게 제공한다 이를 **재검사 적중, 느린적중**이라고 한다.
  - 재검사 적중은 원 서버와 검사할 필요가 있기 때문에 순수 캐시 적중보다 느리다
  - 캐시 부적중 보다는 빠르다.(서버에서 데이터를 받아올 필요가 없기 때문)

  ```markdown
  속도
  캐시 부적중 < 캐시 재검사 적중 < 캐시 적중
  ```

  ![image7-5](./images/7-5.png)

- 재검증 요청 헤더

  - **If-Modified-Since** 헤더: 캐시된 리소스의 `Last-Modified` 값 이후에 서버 리소스가 수정되었는지 확인합니다.
  - **If-None-Match** 헤더: 캐시된 리소스의 `ETag` 값과 현재 서버 리소스의 `ETag` 값이 같은지 확인합니다.

    > `Etag`: 응답 헤더는 특정 버전의 리소스를 식별하는 식별자
    > 웹 서버가 내용을 확인하고 변하지 않았으면 웹 서버로 full 요청을 보내지 않기 때문에 캐시가 더 효율적이게 되고 대역폭을 아낄 수 있다.
    > [https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag)
    >
    > ![ex:request-header](./images/request-header.png)

- 재검사 적중

  - 서버 객체가 변경되지 않았다면 서버는 클라이언트에게 304 Not Modified 응답을 보낸다

    ![image7-6](./images/7-6.png)

- 재검사 부적중
  - 서버 객체가 캐시된 사본과 다르다면 서버는 콘텐츠 전체와 함께 평범한 200 OK 응답을 클라이언트에게 보낸다
- 객체 삭제
  - 서버 객체가 삭제되었다면 서버는 404 Not Found 응답을 보내고, 캐시를 삭제한다.

### 7.5.2 적중률

- 캐시가 요청을 처리하는 비율, 0 - 1 사이의 값
- 0%는 모든 요청이 캐시 부적중임을, 100%는 모든 요청이 캐시 적중임을 의미한다
- 이런 적중률을 예측하기란 어려운일이지만 40%의 적중률이면 괜찮은 편이다

### 7.5.3 바이트 적중률

- 문서들이 모두 같은 크기는 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않는다
  → 큰 객체는 덜 접근되지만 그 크기가 크기때문에 전체 트래픽에서 더 크게 기여한다
- 문서 중 캐시된 바이트의 비율
- 100%라면 모든 바이트가 캐시에서 왔으며 어떤 트래픽도 인터넷으로 나가지 않았다는 의미

### 7.5.4 적중과 부적중의 구별

- 클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은 `Date` 헤더를 이용하는 것이다
- 응답의 Date 헤더값은 현재 시각과 비교하여 응답 생성일이 더 오래되었다면 클라이언트측에서 응답이 캐시된 것임을 알아낼 수 있다
- 또다른 방법은 응답이 얼마나 오래되었는지 말해주는 `Age` 헤더를 이용하는 것이다

## 7.6 캐시 토폴로지

![image7-7](./images/7-7.png)

### 7.6.1 개인 전용 캐시

- 사용자 한명에게만 할당된 캐시, 개인만을 위한 캐시
- 웹 브라우저는 개인 전용 캐시를 내장하고 있다

### 7.6.2 공용 프락시 캐시

- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 사용자의 입장에서 서버에 접근한다. 공용 캐시는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있다
- 공유된 공용 캐시는 자주 찾는 객체를 단 한번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄일 수 있다.

![image7-8](./images/7-8.png)

## 7.7 캐시 처리 단계

![image7-11](./images/7-11.png)

### 요청 받기

- 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다
- 고성능 캐시는 여러개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다

### 파싱

- 메시지를 파싱하여 URL과 헤더들을 추출한다
- 요청 메세지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다

### 검색

- 로컬 복사본이 있는지 검사하고 사본이 없다면 사본을 받아온다
- 캐시는 URL을 알아내고 해당하는 로컬 사본이 있는지 검사한다
  - 없다면 원서버나 프락시에서 가져오거나 실패를 반환한다
- 캐시된 객체는 서버 응답 본문과 원서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있다.
- 캐시된 객체는 얼마나 캐시가 오래되었는지, 얼마나 자주 사용되었는지 등의 메타데이터를 포함하고 있다

### 신선도 검사

- 캐시는 캐시된 사본이 충분히 신선한지 검사하고 신선하지 않다면 변경사항이 있는지 서버에게 물어본다

### 응답 생성

- 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다
- 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다

### 발송

- 네트워크를 통해 응답을 클라이언트에게 돌려준다

### 로깅

- 선택적으로 로크파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다
- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다. 각 캐시 트랜잭션이 완료된 후 캐시는 통계 캐시 적중과 부적중 횟수를 갱신하고 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다.

![image7-12](./images/7-12.png)
